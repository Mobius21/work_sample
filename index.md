## Welcome to My Technical Sample Pages

Here are some technical part from the project I have participated before. 

### College Raptor Group Capstone Project 

The project is sponsored by [College Raptor Inc.](https://www.collegeraptor.com/), a company focused on helping high school students make smarter decisions on choosing their college. College Raptor helps students to find the colleges that fit their needs based on student preferences and personal information. In order to create a more accurate model for College Raptor, the team used data from Melissa. The Melissa API code listed below is part of the work used for the data preparation that gets 10 addresses based on one unique Zip+4.

```markdown
// **Rscript** code with syntax highlighting.

for (n in which(dffull$zpfprocess == "N")){
  tryCatch({
  URLZip = dffull$inputzpf[n]
  jd = 0
  
  while (jd < 10) {
    URL = paste(URLbase, URLZip, URLform,  sep = "")
    # This is the call to the Melissa API
    json_data = suppressWarnings(fromJSON(paste(readLines(URL), collapse="")))
    
    if (length(json_data)==0){
      zpfour[rc,]= c(dffull$inputzpf[n], NA, NA, NA, NA, NA)
      rc = rc+1
      break
    }
    else{
      limit = max(jd+length(json_data), 10)
      if (limit > 10) { a = 10 - jd } else { a = length(json_data) }
      for (i in (1:a)){
        zaddress = json_data[[i]]$Address
        zcityzip = paste(json_data[[i]]$City, json_data[[i]]$State, dffull$inputzpf[n], sep = ', ')
        
        ### add result to a temp data frame
        zpfour[rc,]= c(dffull$sourcezpf[n],
                       dffull$inputzpf[n],
                       json_data[[i]]$Address,
                       json_data[[i]]$City,
                       json_data[[i]]$State)
        ### update the row count
        print(c(rc, dffull$sourcezpf[n]))
        rc = rc+1
      }
    }
    
    jd = jd + length(json_data)
    zipfive <- substr(URLZip, 0, 6)
    zipfour <- as.numeric(substr(URLZip,7,10)) 
    URLZip = paste(zipfive, as.character(zipfour + 1), sep = "")
    dffull$inputzpf[n] = URLZip
  }
    
  dffull$zpfprocess[n] = "Y"
  zpfprocess[n] = "Y"
  
  date_time <- Sys.time()
  while((as.numeric(Sys.time()) - as.numeric(date_time)) < 2){} 
  }, error=function(e){})
}

```

### Iowa City Safest County Project ###

In this project, we assume to provide multiple choice for shelter for families who want to live in the safest county in Iowa.  According to the [Iowa Demographics by Cubic](https://www.iowa-demographics.com/cities_by_population), there are 1004 cities in Iowa, containing approximately 3.2 million residents. Our analysis will be driven by criteria including population, homicides, drug crime, traffic fatalities, income, etc. Our resulting database application will be posted on the website generated by **Oracle Apex** and will be useful for real estate agencies, travel agencies, school districts, police departments, and the public. The following SQL code is what we used to create one of the tables.

```markdown
\\SQL code with syntax highlighting.

CREATE TABLE "NON_SEX_DISEASE"
 (  "NON_SEXID" CHAR(50) NOT NULL ENABLE,
    "COUNTYID" CHAR(50) NOT NULL ENABLE,
    "TYPE_OF_NONSEX_DISEASE" VARCHAR2(50) NOT NULL ENABLE,
    "RATE_OF_NONSEXDISEASE" NUMBER,
    CONSTRAINT "NON_SEX_DISEASE_CON" PRIMARY KEY ("NON_SEXID")
    USING INDEX ENABLE
 )
/
ALTER TABLE "NON_SEX_DISEASE" ADD CONSTRAINT "NON_SEX_DISEASE_CON1"
FOREIGN KEY ("COUNTYID")
 REFERENCES "COUNTY" ("COUNTYID") ENABLE
/
```
One of our problem is to identify the counties with the lower mortality. Potential residents looking for a safe Iowa county to live in will prefer to find a location with a low mortality. However, the ratio of intentional to accidental deaths should be considered when we make a comparison. This information would also be helpful to government officials and police officers in deciding what areas have less need for police presence and examining successful departments and systems within counties with low mortality.

To increase the accuracy, we used a complex formula to get the mortality rate in each county and excluded counties that have mortality rate higher than average. Since the mortality rate we get is small and difficult to represent in percentage form, we used it to order the table from low to high by mortality rate.

```markdown
\\SQL code with syntax highlighting.

SELECT County_Name, Total_Death, TO_CHAR(Population,'999,999,999') as Population
FROM(
  Select County_Name, sum(Number_Of_Deaths) as Total_Death, Population
  FROM Death Join County on Death.CountyID = County.CountyID
  GROUP BY Death.countyID, County_Name, Population
  Having sum(Number_Of_Deaths)/Population <= (
    SELECT avg(Rate)
    FROM (
      SELECT Death.countyID, County_Name, Population, sum(Number_Of_Deaths)/Population as Rate
      FROM Death Join County on Death.CountyID = County.CountyID
      GROUP BY Death.countyID, County_Name, Population
      )
  )
  ORDER BY sum(Number_Of_Deaths)/Population
);


```
